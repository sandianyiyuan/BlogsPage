<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hello world</title>
    <url>/hello/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>按照惯例，从hello world开始，正式开启博客旅途。<br>这算是第一篇文章，以后在这里做笔记、分享日常。</p>
<p>如果有什么建议或者意见可以在文章末尾留言，由于使用的是第的三方评论系统，你的留言我可能看到不及时，而且回复你也不会收到提醒，如果想要与我沟通的话可以在博客讨论区与我交流：<a href="https://github.com/sandianyiyuan/BlogsPage/discussions">传送门</a>  或者在<a href="../about/index">关于我</a>页面通过其他联系方式找到我。</p>
]]></content>
  </entry>
  <entry>
    <title>hexo中本引用本站链接</title>
    <url>/hexo%E4%B8%AD%E6%9C%AC%E5%BC%95%E7%94%A8%E6%9C%AC%E7%AB%99%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在本地写md文件，在某篇文章中想引用其他文章，通过markdown的语法插入文章后，在本地跳转是OK的，但hexo生成静态文件部署之后的文章链接就不对了。<br>例如：我在这篇文章中引用“关于我”的页面。<br>这个地址在本地能正常跳转，部署后不能跳转：<br><a href="../../about/index.md">关于我</a></p>
<p>插入的链接如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[关于我](..&#x2F;..&#x2F;about&#x2F;index.md)</span><br></pre></td></tr></table></figure>
<p>在本地点击链接是可以正常跳转的，部署后web上文章的路径发生了变化，点击链接跳转就发生了错误。<br>原因有几点：<br>1.hexo的配置文件中 permalink 项是配置永久链接格式的。默认是年月日加文件路径，导致文件相对路径不正确的原因就是加了年月日，使网页路径与本地文件路径发生了变化，解决这个问题，可以去掉 permalink 配置中的年月日，只设置<code>:title/</code>就与与本地文件一致了。<br>2.现在解决了相对路径的问题，还有文件后缀存在问题。<br> md 文件中引用文件路径写的是 *.md , hexo 渲染的网页中还是 md ，导致页面还是访问不到，解决这个问题可以去掉链接中的后缀，这样markdown编辑器在本地能识别链接的文件，渲染后在浏览器中也能正常跳转。<br> 插入链接地址如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[关于我](..&#x2F;..&#x2F;about&#x2F;index)</span><br></pre></td></tr></table></figure>
<p>这个地址在本地能正常跳转，部署后也能跳转：<br><a href="../../about/index">关于我</a></p>
]]></content>
      <tags>
        <tag>技术</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>keepass(密码管理工具)</title>
    <url>/keepass/keepass(%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7)/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>官方网站<a href="https://keepass.info/">keepass.info</a><br>github上已经两个项目全面地介绍了keepass及插件的使用方法：<br><a href="https://github.com/1688aa/KeePass-Plugins-Instructions-for-use">github.com/1688aa/KeePass-Plugins-Instructions-for-use</a><br><a href="https://github.com/1688aa/KeePass-Instructions-for-use">github.com/1688aa/KeePass-Instructions-for-use</a></p>
<p>KeePass 是一款免费的开源密码管理器，KeePass 将密码存储为一个数据库，而这个数据库由一个主密码或密码文件锁住，也就是说我们只需要记住一个主密码，或使用一个密码文件，就可以解开这个数据库，就可以获得其他的密码内容。<br>办公室电脑密码、笔记本密码、家里电脑密码、上网帐号密码、手机服务密码、邮箱密码、QQ 密码、银行卡查询密码、银行卡交易密码、银行卡网上支付密码……我们需要记太多太多的密码。纵然我们可以使一些密码一致，但无法让所有的密码都一样，到头来，我们仍要记不少的密码，尤其是对于掌握信息系统的人来说，密码更多了。</p>
<p>实际上把密码记下来，也不代表不安全，完全留在脑中，反而容易忘记。所以有了 KeePass。</p>
]]></content>
      <categories>
        <category>工具软件</category>
        <category>keepass</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>工具软件</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>mybase(个人笔记软件)</title>
    <url>/keepass/mybase(%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6)/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>myBase 是一款用于分类管理任意格式文档资料的小型个人数据库软件， 有助于个人用户在 (Linux/MacOSX/Windows)桌面电脑系统上实施文档、笔记、日记、图片和网页等知识内容的分类管理。 借助软件提供的各项功能，创建和维护一个专属于自己的个人知识库将变的非常容易。 与传统意义上的数据库软件不同，myBase 通过内置的富文本编辑器接受图文信息的输入，并按树形大纲分门别类保存，同时接受任意磁盘文件作为大纲条目的附件。 myBase 提供了更好的方式使知识/信息的捕获、编辑、组织、查看、索引、搜索和分享变得更快捷、更容易。<br>对于工作中的一些个人笔记，可以用mybase存放，使用mybase可以避免文件散落在磁盘的各个地方。</p>
]]></content>
      <categories>
        <category>工具软件</category>
        <category>mybase</category>
      </categories>
      <tags>
        <tag>工具软件</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux定时任务配置</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Linux定时任务配置在线生成工具：<a href="https://cron.qqe2.com/">https://cron.qqe2.com/</a></p>
]]></content>
      <tags>
        <tag>技术</tag>
        <tag>工具软件</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Obsidian使用笔记</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Obsidian%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Obsidian-超好用的笔记软件"><a href="#Obsidian-超好用的笔记软件" class="headerlink" title="Obsidian 超好用的笔记软件"></a>Obsidian 超好用的笔记软件</h2><p>官网地址：<a href="https://obsidian.md/">obsidian.md</a><br>软件自带的说明文档已经很详细的说明了使用方法，直接安装后开始研究。</p>
<p>如果你已经下载好obsidian，现在点击打开它。映入眼帘的是它的默认界面风格，我们马上就要改掉它，因为它不够快捷、直接。如果你曾有过开发经验，在一些开发IDE编辑器里写过代码，那obsidian的使用体验会让你如鱼得水，如果你没有开发经验也无妨，因为obsidian脱胎于markdown文本编辑器，你只要写过markdown文件，obsidian对你就是零门槛。即便你也从未用过markdown文件，也没关系，obsidian的操作及其简单，你只需要对着范例稍微熟悉最多半小时就可以轻松上手。点开范例随时开启obsidian之旅：点击help可以打开自带的示例库，里面有非常详细的使用说明。</p>
]]></content>
      <categories>
        <category>工具软件</category>
        <category>Obsidian</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>工具软件</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>github仓库开启Discussions</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/github%E4%BB%93%E5%BA%93%E5%BC%80%E5%90%AFDiscussions/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>才发现github仓库可以开Discussions。<br>该功能在settings-&gt;Options中，勾选Discussions就可开启。<br>开启后就可以方便的讨论问题而不用提issue了。<br>快来跟我一起讨论吧<a href="https://github.com/sandianyiyuan/BlogsPage/discussions">传送门</a></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo搭建博客的过程</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>hexo d 部署报错 ERROR Deployer not found: git 需要安装插件<br><code>npm install --save hexo-deployer-git</code></p>
<h2 id="多电脑托管的处理方式"><a href="#多电脑托管的处理方式" class="headerlink" title="多电脑托管的处理方式"></a>多电脑托管的处理方式</h2><p>在公司电脑源码构建完成，回到家换了一台电脑想继续弄，应该怎么做？<br>直接将代码库拉下来是不行的，因为代码库中并没有托管全部所需的依赖包<br>应该在新电脑上执行<code>hexo init</code>，创建一个新的hexo项目，然后再将git库中的内容克隆到另一个目录中，克隆完之后，将所有的文件拷贝到刚才初始化的hexo项目目录中。并安装所需要的hexo插件。一切都完成之后就可以继续写文章，提交内容了 。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>工具软件</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs笔记</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/nodejs/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>找到一个纯静态的导航页项目，说是纯静态，但它又能在线增加删除导航站上的网址，感觉很神奇。<br>发现它是利用 github 的流水线来实现的自动构建，在 Actions 页可以看到其 yml 配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name: Build web</span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches:</span><br><span class="line">      - master</span><br><span class="line">      - main</span><br><span class="line">jobs:</span><br><span class="line">  build:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">    - name: Checkout</span><br><span class="line">      uses: actions&#x2F;checkout@v2</span><br><span class="line">      with:</span><br><span class="line">        persist-credentials: false</span><br><span class="line">    - name: Install</span><br><span class="line">      uses: sergioramos&#x2F;yarn-actions&#x2F;install@v6</span><br><span class="line">      with:</span><br><span class="line">        frozen-lockfile: true</span><br><span class="line">    - name: Build</span><br><span class="line">      run: |</span><br><span class="line">        npm run build</span><br><span class="line">    - name: Deploy</span><br><span class="line">      uses: JamesIves&#x2F;github-pages-deploy-action@releases&#x2F;v3</span><br><span class="line">      with:</span><br><span class="line">        ACCESS_TOKEN: $&#123;&#123; secrets.TOKEN &#125;&#125;</span><br><span class="line">        BRANCH: gh-pages</span><br><span class="line">        FOLDER: dist</span><br></pre></td></tr></table></figure>
<p>那么执行 <code>npm run build</code> 时发生了什么？</p>
]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>币圈初窥</title>
    <url>/%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81/%E5%B8%81%E5%9C%88%E5%88%9D%E7%AA%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&#8194;&#8194;最近币市又疯狂了，手痒，也想了解一下电子货币的工作原理。<br>周末两天啥都没干，就百度谷歌微博知乎油管B站到处搜，找比特币相关介绍，其实一年前在上一波电子货币火热的时候就在B站看过<a href="https://space.bilibili.com/9458053?from=search&seid=11778469763140839529">李永乐老师</a>讲<a href="https://www.bilibili.com/video/BV1Bb411B7dq">比特币和区块链啥原理？矿机挖矿咋回事？</a>,这又看了一遍。<br>另外注册了OKEX和火币交易所，在上面买入卖出跑通了交易流程，后面了解了比特币钱包的加密性质和大概原理，感觉交易平台上买的币不实在，去中心化的货币在交易平台上应该是集中记账的，否则平台上转账做不到秒转，在后来看到的视频中也有博主强调了这一点，如果不是在交易平台上炒币的话，尽量不要放太多币在平台上，平台只用于买入卖出，交易完就应该马上提现离场。<br>然后就开始找合适的钱包了，在谷歌应用商店里里下载了十多个电子货币钱包，最后只楼下了比太和比特派，比太可以做冷钱包，比特派是热钱包，同时可以监控冷钱包的钱，不得不说比特币系统设计得很巧妙。<br>万事俱备就差币了，买了一点比特币和以太坊由于提现需要手续费，买得又少，暂时先不提到自己钱包上了。<br>然后看到我的电脑买来闲置很久了，正好显卡是RX580不拿来挖矿实在可惜。又花半天找挖矿程序，网上大多数挖矿软件会报毒，网友都说是正常的，随你们信不信，反正我不信。在github上找的正规内核程序，根本不报毒。<br>好了，让它跑一晚上，我也感受一下睡后收入，预计可能有几块块钱😂</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>加密货币</tag>
      </tags>
  </entry>
  <entry>
    <title>币海大浪涛涛 人心左右摇</title>
    <url>/%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81/%E5%B8%81%E6%B5%B7%E5%A4%A7%E6%B5%AA%E6%B6%9B%E6%B6%9B%20%E4%BA%BA%E5%BF%83%E5%B7%A6%E5%8F%B3%E6%91%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>币圈有句话“币圈一天，人间一年”。<br>最近币圈跌得生猛，前面投进去试水的一点钱，赶上大涨，后又大跌。真的应了这那句话。  目前浮亏一两个点，我是作为探索和研究加密货币而投资的，资金量不大而且都是现货，任它涨跌我就不动，看它到底要干啥。</p>
]]></content>
      <categories>
        <category>日常</category>
        <category>随想</category>
      </categories>
      <tags>
        <tag>加密货币</tag>
      </tags>
  </entry>
  <entry>
    <title>Anywhere 快捷卡片应用</title>
    <url>/%E6%97%A5%E5%B8%B8/Anywhere%20%E5%BF%AB%E6%8D%B7%E5%8D%A1%E7%89%87%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Anywhere 是一款快捷卡片应用，可以在桌面灵活的创建应用快捷方式。</p>
<p>有时候在群里说了一句话没人理我，然后我就想，能不能不说这么多废话，或者换一个地方说？ 不说憋着不舒服，发朋友圈感觉又不合适，想来想去好像只有微博最适合日常吐槽，发一些乱七八糟的东西。<br>这时候发现微博发文不像在群里说话那样输入内容点 send 就发出去了，微博稍微繁琐一些。想找一款第三方的客户端，它只有一个类似微信对话窗口，输入内容点 send 就能发博，避免停留在微博首页时间太长被其他信息干扰。<br>找来找去没找到合适的客户端，最后还是用了微博的官方客户端。<br>后来想到之前安装的快捷方式卡片能创建一个快捷方式，通过快捷方式可以直接打开编辑微博的页面，感觉这也很方便快捷。<br>上手之后发现确实不错。  </p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么身边没人用飞书</title>
    <url>/%E6%97%A5%E5%B8%B8/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BA%AB%E8%BE%B9%E6%B2%A1%E4%BA%BA%E7%94%A8%E9%A3%9E%E4%B9%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>工作原因，从微信QQ沟通交流转到了钉钉，钉钉里面的工具大而全，但使用起来总感觉哪里不舒服，体验不是很好。<br>自己也注册了飞书，感觉飞书简洁轻便，里面的待办、日历、文档等都非常的优秀，不得不赞。想找朋友一起用，推荐给朋友都会问为什么要用，钉钉能做了，沟通交流有微信和QQ，没必要用飞书了。。。<br>好想找几个人拉个团队一起来体验一下新工具。</p>
]]></content>
      <categories>
        <category>日常</category>
        <category>随想</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>反诈宣传</title>
    <url>/%E6%97%A5%E5%B8%B8/%E5%8F%8D%E8%AF%88%E5%AE%A3%E4%BC%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>国家为了反诈骗也是操碎了心，开发出一款叫“国家反诈中心”的APP，公司为了完成任务要求强制安装。<br>出于习惯，反对一切强制的行为。<br>如果给我安利说这APP里有一些很牛皮的功能，建议装了看看，我可能出于好奇会安装体验一下，但直接强制要我安装的话就不一样了，出于对自己隐私的保护，我是拒绝安装的，它要的权限真的太多了。</p>
]]></content>
      <categories>
        <category>日常</category>
        <category>随想</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>关于焦虑</title>
    <url>/%E6%97%A5%E5%B8%B8/%E7%84%A6%E8%99%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这几天感觉浑身不舒服，跟焦虑症的症状全都对上了<br>知乎上搜到篇文章<a href="https://zhuanlan.zhihu.com/p/25909485">焦虑，是闲出来的病，是懒出来的症</a>  </p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
  </entry>
  <entry>
    <title>纠结症</title>
    <url>/%E6%97%A5%E5%B8%B8/%E7%BA%A0%E7%BB%93%E7%97%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>经常会发生想做一件事又怕麻烦或者还没开始做就想得很远很远，怕开头的方向不对，导致后面纠正麻烦的情况，然后就让自己陷入无尽的纠结之中。<br><img src="https://z3.ax1x.com/2021/05/24/gjbShj.jpg" alt="抓狂"></p>
<a id="more"></a>
<p>比如，我想搭博客，在博客中分享日常，这本来是一个挺好的想法，多了解一下之后发现在博客中可以打广告挣钱，要想挣钱就得分享有意义的内容，到这里又会想，既然要挣钱怎么不去做公众号呢？公众号更好引流，接着我又去查小白如何运营公众号，网上说首先是要找准定位，然后在细分领域中深耕细作，这一下又得想定位，开始想自己如何定位、哪个领域合适，怕定位不准，导致后期运营麻烦。你看，到这一步是不是想得太多了，这时候我意识到自己似乎已经背离写博客的初衷了。</p>
<p>晚上我开始思考，为什么这么纠结呢？我想到一句话是这么说的：种一棵树最好的时间是十年前，其次是现在。<br>对于有纠结症的人来说，种树之前是不是要问种什么树？可是为什么没人这么问，大概是没意义吧，随便啥树先种上再说，不要想以后这树是用来乘凉还是吃果子，要是拿来吃果子的话，是不是又要想应该种啥水果呢？未免太累了。</p>
]]></content>
      <categories>
        <category>日常</category>
        <category>随想</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>送别国之脊梁袁隆平</title>
    <url>/%E6%97%A5%E5%B8%B8/%E9%80%81%E5%88%AB%E5%9B%BD%E4%B9%8B%E8%84%8A%E6%A2%81%E8%A2%81%E9%9A%86%E5%B9%B3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>【痛悼！送别国之脊梁袁隆平】今天，共和国痛失袁隆平院士。<br>“我最大的愿望是饭碗要牢牢地掌握在我们中国人自己手上！”<br>他把一生浸在稻田里，把功勋写在大地上。国士无双，致敬，缅怀！<br><img src="https://z3.ax1x.com/2021/05/22/gLpCq0.jpg" alt="袁隆平"></p>
]]></content>
  </entry>
  <entry>
    <title>GitLabPages</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/GIT/GitLabPages/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>cnblogs.com/zhangnan35/p/10709252.html</p>
<p>配置Gitlab pages和Gitlab CI<a href="https://www.cnblogs.com/zhangnan35/p/10709252.html">参考文档：https://www.cnblogs.com/zhangnan35/p/10709252.htm</a></p>
<p>　　首先，Gitlab pages是很简单的，至少比起github pages要简单很多。</p>
<p>　　Gitlab Pages的原理这是样的：首先，当你新建一个Gitlab项目的时候，你同时也建了一个存储库。</p>
<p>　　只要你的工程目录的根目录下有.gitlab-ci.yml文件，注意必须严格起这个名字。gitlab runner就会执行这个脚本文件。</p>
<p>　　脚本的最终目的很简单：把静态文件放入名为public目录下的文件夹内。Gitlab pages会一直去这个存储库的public目录找。注意：这个public是指存储库的public，与项目结构无关。换言之，这个public目录不可见。</p>
<p>　　也就是说：当你在项目的根目录下添加了.gitlab-ci.yml，且在脚本中将静态文件正确地放入了public文件夹，gitlab page就会自动打开并部署，部署的域名将会默认分配。</p>
<p>　　当然，如果你不想使用默认的配置，而是想部署到特定的域名和服务器，则需要在yml文件中进行一些docker的配置。</p>
<p>　　开发者提交代码后,runner检索项目根目录下名为**.gitlab-ci.yml<strong>的文件，并执行文件中的脚本，脚本内容包括项目的运行，打包，缓存打包文件，转移文件到</strong>public**目录以供gitlab pages使用。而gitlab pages会到public目录中解析静态文件成页面。</p>
<p>　　好，现在就来看一下我写的一份CI脚本，首先说一下，CI的代码风格类似于python这种，纯靠缩进来区分层级关系的，所以书写时，<strong>缩进是严格的</strong>。</p>
<p>　　<img src="GitLabPages/%E4%B8%80%E4%BB%BDCI%E8%84%9A%E6%9C%AC.png" alt="img"></p>
<p>　　下面是代码注释版版的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">building: &#x2F;&#x2F;自己随便命名的</span><br><span class="line">  image: node:latest &#x2F;&#x2F;node镜像为最新版的，最好指定版本号</span><br><span class="line">  stage: build &#x2F;&#x2F;当前stage阶段为build</span><br><span class="line">  script: &#x2F;&#x2F;build阶段运行的脚本</span><br><span class="line">    - npm install --progress&#x3D;false --no-optional &#x2F;&#x2F;根据package.json来安装依赖 progress设为false是为了不打印安装的具体进度，no optional是为了跳过npm推荐的但不是编译必须的，也没有写在package.json里一些依赖，比如说查看源代码等</span><br><span class="line">    - npm run build &#x2F;&#x2F;打包</span><br><span class="line">  artifacts: &#x2F;&#x2F;工件，可以缓存在gitlab的流水线记录中，供直接下载</span><br><span class="line">    expire_in: 3 days &#x2F;&#x2F;工件缓存的有效时间</span><br><span class="line">    paths: &#x2F;&#x2F;路径</span><br><span class="line">      - dist &#x2F;&#x2F;工件指向的目录，这里指整个dist目录</span><br><span class="line"></span><br><span class="line">cache: &#x2F;&#x2F;缓存</span><br><span class="line">  paths: &#x2F;&#x2F;路径</span><br><span class="line">    - node_modules&#x2F; &#x2F;&#x2F;缓存node_mudules将大大提高ci运行的速度</span><br><span class="line"></span><br><span class="line">pages: &#x2F;&#x2F;随便起的名字</span><br><span class="line">  stage: deploy &#x2F;&#x2F;当前阶段为deploy</span><br><span class="line">  script: &#x2F;&#x2F;deploy阶段运行的命令</span><br><span class="line">    - rm -rf public&#x2F;* &#x2F;&#x2F;linux命令，递归无询问删除public目录下所有文件- mv dist&#x2F;* public &#x2F;&#x2F;将dist目录下的所有文件都移动到public目录下</span><br><span class="line">  artifacts: &#x2F;&#x2F;工件缓存</span><br><span class="line">    expire_in: 3 days &#x2F;&#x2F;时效为3天</span><br><span class="line">    paths: &#x2F;&#x2F;路径</span><br><span class="line">      - public &#x2F;&#x2F;缓存整个public目录的文件</span><br><span class="line">  only: </span><br><span class="line">    - dev &#x2F;&#x2F;ceate pages下的所有操作只在dev分支上进行</span><br></pre></td></tr></table></figure>
<p>　　下载一个工件下来看看：</p>
<p>　　<img src="GitLabPages/%E5%B7%A5%E4%BB%B6.png" alt="img"></p>
<p>　　可以发现我所言非虚。这时候我们把这个提交推到远程。</p>
<p><img src="GitLabPages/%E6%8F%90%E4%BA%A4%E5%88%B0%E8%BF%9C%E7%A8%8B.png" alt="img"></p>
<p>　　等待这个流水线跑完，在 <strong>项目 –&gt; 设置 –&gt; pages</strong> 中，可以看到线上页面已经生成了。</p>
<p>　　<img src="GitLabPages/%E6%9F%A5%E7%9C%8B%E9%A1%B5%E9%9D%A2.png" alt="img"></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>github Actions</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/GIT/github%20Actions/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>参考文章 <a href="https://zhuanlan.zhihu.com/p/164744104">https://zhuanlan.zhihu.com/p/164744104</a><br>github Actions 官方文档 <a href="https://docs.github.com/en/actions">https://docs.github.com/en/actions</a></p>
<h3 id="1、我们应该如何使用-Action？"><a href="#1、我们应该如何使用-Action？" class="headerlink" title="1、我们应该如何使用 Action？"></a>1、我们应该如何使用 Action？</h3><p>比如我们可以 check-out 仓库中最新的代码到 Workflow 的工作区：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">steps:</span><br><span class="line">  - uses: actions/checkout@v2</span><br></pre></td></tr></table></figure>
<p>当然，我们还可以给它添加个名字：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">steps:</span><br><span class="line">  - name: Check out Git repository</span><br><span class="line">    uses: actions/checkout@v2</span><br></pre></td></tr></table></figure>
<p>再比如说，我们如果是 node 项目，我们可以安装 Node.js 与 NPM：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">steps:</span><br><span class="line">- uses: actions/checkout@v2</span><br><span class="line">- uses: actions/setup-node@v2-beta</span><br><span class="line">  with:</span><br><span class="line">    node-version: &#x27;12&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="2、上面我们为什么要用：-v2-和-v2-beta-呢？"><a href="#2、上面我们为什么要用：-v2-和-v2-beta-呢？" class="headerlink" title="2、上面我们为什么要用：@v2 和 @v2-beta 呢？"></a>2、上面我们为什么要用：@v2 和 @v2-beta 呢？</h3><p>答：首先，正如大家所想，这个 @v2 和 @v2-beta 的意思都是 Action 的版本。</p>
<p>我们如果不带版本号的话，其实就是默认使用最新版本的了。</p>
<p>但是 <strong>Github 官方强烈要求我们带上版本号</strong>——这样子的话，我们就不会出现：<strong>写好一个 Workflow，但是由于某个 Action 的作者一更新，我们的 Workflow 就崩了的问题。</strong></p>
<h3 id="如何运行命令？"><a href="#如何运行命令？" class="headerlink" title="如何运行命令？"></a>如何运行命令？</h3><p>使用<code>run</code>来运行命令，<strong>每个 run 命令都会启动一个新的 shell，所以我们执行多行连续命令的时候需要写在同一个 run 下：</strong></p>
<ul>
<li><strong>单行命令</strong><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">- name: Install Dependencies</span><br><span class="line">  run: npm install</span><br></pre></td></tr></table></figure></li>
<li>  <strong>多行命令</strong></li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">- name: Clean install dependencies and build</span><br><span class="line">  run： |</span><br><span class="line">    npm ci</span><br><span class="line">    npm run build</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用指令笔记</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/GIT/git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="删除远程所有分支"><a href="#删除远程所有分支" class="headerlink" title="删除远程所有分支"></a>删除远程所有分支</h2><h2 id="删除远程文件"><a href="#删除远程文件" class="headerlink" title="删除远程文件"></a>删除远程文件</h2><p>多人协作中经常有人将中间文件提交，他人提交之后如果需要删除的话可以这样操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rm -r --cached *.iml        &#x2F;&#x2F;*.iml 是需要删除的文件</span><br><span class="line">git commit -m &quot;ignore *.iml&quot;    &#x2F;&#x2F;&quot;ignore *.iml&quot;是提交的备注</span><br><span class="line">git push </span><br></pre></td></tr></table></figure>
<p>该操作删除远程的文件，本地文件不受影响，但是别人pull代码之后本地的目录会被删除</p>
<p>再修改.gitignore文件将其忽略规则加上，别人就不会提交这个文件了。</p>
<p>gitignore文件规则，只能忽略未被添加到跟踪的文件，作用范围为当前目录的子目录</p>
<p>如果文件已经被跟踪，则忽略规则不生效;已经被跟踪的文件被删除后忽略规则会生效。</p>
<p>文件被跟踪后又被删除再被创建时如果满足忽略规则，则不会被跟踪。</p>
<h2 id="重置远程分支"><a href="#重置远程分支" class="headerlink" title="重置远程分支"></a>重置远程分支</h2><p>本地分支与远程分支不同步时，拉取所有分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git fetch	# 将远程所有分支拉取到本地，这时候使用</span><br><span class="line">git checkout -b dev(本地分支名称) origin&#x2F;dev(远程分支名称)</span><br></pre></td></tr></table></figure>
<h2 id="git-stash恢复文件"><a href="#git-stash恢复文件" class="headerlink" title="git stash恢复文件"></a>git stash恢复文件</h2><p>参考文档<a href="https://www.cnblogs.com/exmyth/p/6213129.html">https://www.cnblogs.com/exmyth/p/6213129.html</a></p>
<p>今天在提交脚本的时候不小心删除了数据，瞬间崩溃了</p>
<p>丢代码的过程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash save &quot;暂存文件&quot;</span><br><span class="line">git pull	# 下载最新的文件，下载很正常没提示错误</span><br><span class="line">git stash apply stash@&#123;0&#125;	# 将暂存的文件还原回来</span><br><span class="line">git stash drop stash@&#123;0&#125;	# 删除暂存的文件</span><br><span class="line">git status # 检查文件状态</span><br></pre></td></tr></table></figure>
<p>这时候提示没有任何提示，现在工作区是干净的，然后就没有然后了。我也不知道我改了哪些文件改了啥，人都懵了。</p>
<p>果断上网百度，发现有还原的方法，记录如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git fsck --lost-found	# 查看最近删除的提交，其中就有git stash drop stash@&#123;0&#125;时的ID</span><br><span class="line">git show id		# 查看文件记录，id是git fsck指令查出来的ID，找到要还原的记录</span><br><span class="line">git merge id	# 这样就可以将记录还原了。</span><br></pre></td></tr></table></figure>
<h2 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h2><p><code>git tag</code> 在控制台打印出当前仓库的所有标签<br><code>git tag tagName commitId</code> 对之前的commit打标签<br><code>git tag v1.0</code> 对最后一次commit打标签<br><code>$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb</code>创建带有说明的标签，用-a指定标签名，-m指定说明文字：<br><code>git tag -l ‘v0.1.*’</code> 搜索符合模式的标签<br><code>git push origin [tagname]</code> push单个tag<br><code>git push [origin] --tags</code> push所有tag  </p>
<p><code>git checkout tagName</code> 根据标签名检出</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>java 学习笔记</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JAVA/java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>ipml 接口的实现类</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库笔记</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="未找到父项关键字"><a href="#未找到父项关键字" class="headerlink" title="未找到父项关键字"></a>未找到父项关键字</h2><p>考虑子表中数据已经与主表不一致，可能存在主表没有的数据。<br>解决方法： 先把数据查出来删除再添加外键。<br>查询语句如下：  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">DISTINCT</span>  st.id <span class="keyword">from</span> sub_tab st </span><br><span class="line"><span class="keyword">where</span> st.id  <span class="keyword">NOT</span> <span class="keyword">in</span> (<span class="keyword">select</span> ft.id <span class="keyword">from</span> parent_tab ft);</span><br></pre></td></tr></table></figure>
<p>看一眼数据，确认之后，将这些数据删除。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> sub_tab st  <span class="keyword">where</span> st.id <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">DISTINCT</span>  st.id <span class="keyword">from</span> sub_tab st </span><br><span class="line"><span class="keyword">where</span> st.id  <span class="keyword">NOT</span> <span class="keyword">in</span> (<span class="keyword">select</span> ft.id <span class="keyword">from</span> parent_tab ft););</span><br></pre></td></tr></table></figure>
<h2 id="名称已被现有约束条件占用"><a href="#名称已被现有约束条件占用" class="headerlink" title="名称已被现有约束条件占用"></a>名称已被现有约束条件占用</h2><p>外键也有自己的名字，报这个错可能是名字其他地方占用了，换个名字就可以了</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello SpringBoot</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SpringBoot/Hello%20SpringBoot/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Hello SpringBoot</p>
<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>创建SpringBoot项目需要联网获取依赖。<br>官方提供的创建方式：<a href="https://start.spring.io/">https://start.spring.io/</a><br>如果上面个地址不能访问，可以试试阿里提供的站点<a href="https://start.aliyun.com/bootstrap.html">https://start.aliyun.com/bootstrap.html</a></p>
<p>创建项目的参考<a href="https://blog.csdn.net/qq_42539533/article/details/90607415">https://blog.csdn.net/qq_42539533/article/details/90607415</a></p>
<p>创建项目需要填写一些信息<br><code>Group</code>：<strong>项目组织</strong>的唯一标识符，通常分为多个段，自己使用随便设置即可（我一般使用host.sdyy，sdyy是我网名的缩写）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">介绍两段的写法,第一段为域,第二段为公司名称</span><br><span class="line">域又分为org、com、cn等,其中org为非营利组织,com为商业组织,cn表示中国,这个根据自己的域名来写</span><br><span class="line">例如apache公司的tomcat项目:org.apache.tomcat</span><br><span class="line">- Group 是org.apache</span><br><span class="line">- 域是org</span><br><span class="line">- 公司名称是apache</span><br><span class="line">- Artifact是tomcat</span><br></pre></td></tr></table></figure>
<p><code>Artifact</code>：<strong>项目</strong>的唯一的标识符，就是项目的名称，不能有大写，都是小写！</p>
<p>因此Grounp+Artifact就相当于项目的坐标，保证了项目的唯一性</p>
<p><code>Name</code>：默认同Artifact，声明了一个对于用户更为友好的项目名称，不是必须的</p>
<p><code>Description</code>：项目描述</p>
<p><code>Package name</code>：指定main目录里java下的包名称，默认为Group+Artifact</p>
<p><code>Packaging</code>：打包方式</p>
<p><code>version</code>：指定了项目的当前版本，SNAPSHOT意为快照，说明该项目还处于开发中，是不稳定的版本</p>
<p>所有信息填写完成之后，点击页面上的获取代码，根据提示下载或者克隆代码。</p>
<p>将项目导入到 IDEA 中，执行一下 MAVEN Updata 。<br>找到主程序，点击运行，就可以在本地浏览器访问到页面了。<br><img src="Hello%20SpringBoot/Pasted%20image%2020210603161006.png"></p>
<p>关于基础包，使用默认的值 Group + Artifact 生成的代码在 IDE 中会提示包路径不对：<br><img src="Hello%20SpringBoot/Pasted%20image%2020210603162636.png"></p>
<p>自己重新设置一下，去掉 Artifact ，生成的就正常了。</p>
<p>阿里在线生成的是一个多模块的项目，各层是个独立的模块。<br>这样做有什么好参考这篇文章<a href="https://blog.csdn.net/weixin_30361753/article/details/96202803">https://blog.csdn.net/weixin_30361753/article/details/96202803</a><br>maven多模块项目的使用，参考这篇文章<a href="https://blog.csdn.net/tomcat_2014/article/details/50206197">https://blog.csdn.net/tomcat_2014/article/details/50206197</a></p>
<h2 id="关于三层架构-与-MVC-的一些概念"><a href="#关于三层架构-与-MVC-的一些概念" class="headerlink" title="关于三层架构 与 MVC 的一些概念"></a>关于三层架构 与 MVC 的一些概念</h2><p>三层架构将整个项目划分为：表现层（UI）、业务逻辑层（BLL）、数据访问层（DAL）<br>MVC 即Model（模型），View（视图），Controller（控制）</p>
<p>相关概念：</p>
<ul>
<li>entity  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">别名： model 层、domain 层、PO(Persistant Object)持久化对象</span><br><span class="line">作用： 用于存放我们的实体类，与数据库中的属性值基本保持一致，实现set和get的方法。</span><br></pre></td></tr></table></figure></li>
<li> mapper  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">别名： dao ( data access object ) 数据访问  </span><br><span class="line">用途： 对数据库进行数据持久化操作，他的方法语句是直接针对数据库的操作，主要实现一些增删改查操作。</span><br></pre></td></tr></table></figure></li>
<li>service  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用途： 业务 service 层，给 controller 层的类提供接口进行调用。一般就是自己写的方法封装起来，就是声明一下，具体实现在serviceImpl中。</span><br></pre></td></tr></table></figure></li>
<li>controller  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">别名： web 层、控制层 </span><br><span class="line">用途： 负责具体模块的业务流程控制，需要调用 service 逻辑设计层的接口来控制业务流程。 controller 通过接收前端 H5 或者 App 传过来的参数进行业务操作，再将处理结果返回到前端。</span><br></pre></td></tr></table></figure></li>
<li>dto ( Data Transfer Object )<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据传输对象。这个传输通常指的前后端之间的传输  </span><br><span class="line">dto 是一个比较特殊的对象，他有两种存在形式：  </span><br><span class="line">1. 在后端，他的存在形式是java对象，也就是在controller里面定义的那个东东，通常在后端不需要关心怎么从json转成java对象的，这个都是由一些成熟的框架帮你完成啦，比如spring框架  </span><br><span class="line">2. 在前端，他的存在形式通常是js里面的对象（也可以简单理解成json），也就是通过ajax请求的那个数据体  </span><br><span class="line">dto 是一个普通的Java类，它封装了要传送的批量的数据。  </span><br><span class="line">当客户端需要读取服务器端的数据的时候，服务器端将数据封装在 dto 中，这样客户端就可以在一个网络调用中获得它需要的所有数据</span><br></pre></td></tr></table></figure>
<h3 id="Mybatis-Mapper"><a href="#Mybatis-Mapper" class="headerlink" title="Mybatis Mapper"></a>Mybatis Mapper</h3></li>
</ul>
<p>参考文章 <a href="https://www.cnblogs.com/demingblog/p/9544774.html">https://www.cnblogs.com/demingblog/p/9544774.html</a><br>参考文章<a href="https://blog.csdn.net/solocoder/article/details/84990904">https://blog.csdn.net/solocoder/article/details/84990904</a>  </p>
<p>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。<br>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。<br>我们在使用 Mybaits 进行 ，通常只需要定义几个 Mapper 接口，然后在编写一个 xml 配置文件，我们在配置文件中写好 sql , Mybatis 帮我们完成 Mapper 接口到具体实现的调用，以及将结果映射到 model bean 中。<br>我们只需要在项目中编写众多的 Mapper 接口类，根据 Java 的多态性我们知道，可以使用接口接口作为形参，进而在运行时确定具体实现的对象是什么。但是，对于 Mapper 接口，我们并没有编写其实现类，Mybatis 帮我们自动生成代理类，实现了数据库的操作。</p>
<h2 id="遇到的报错"><a href="#遇到的报错" class="headerlink" title="遇到的报错"></a>遇到的报错</h2><p><code>Invalid bound statement (not found)</code><br>解决办法：检查扫包是否添加，尝试补全包路径。<br>我的代码中扫包路径写时存在问题，补全子路径后没报错了。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例：  </span><br><span class="line">mapper 类所在包： package host.sdyy.mapper;</span><br><span class="line">config 类（有 @Configuration 注解 ）上的 MapperScan 注解：@MapperScan(&quot;host.sdyy&quot;)  </span><br><span class="line">改为 @MapperScan(&quot;host.sdyy.mapper&quot;) 后问题解决</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 多对多</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SpringBoot/Spring%20Boot%20%E5%A4%9A%E5%AF%B9%E5%A4%9A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>参考文章<a href="https://www.cnblogs.com/TimerHotel/p/springboot_matatis_05.html">https://www.cnblogs.com/TimerHotel/p/springboot_matatis_05.html</a></p>
<p>多对多的查询方法和一对多本质上是一样的，只是在创建数据库表的时候多了一张中间表，用于维护关联关系</p>
]]></content>
  </entry>
  <entry>
    <title>SpringBoot搭建博客</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SpringBoot/SpringBoot%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>参考文章：<a href="https://www.cnblogs.com/superfj/p/9044532.html">https://www.cnblogs.com/superfj/p/9044532.html</a></p>
<p>项目代码：<a href="https://github.com/JayTange/Jantent">https://github.com/JayTange/Jantent</a></p>
]]></content>
  </entry>
  <entry>
    <title>SpringBoot配置文件</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SpringBoot/SpringBoot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>配置文件 <code>application.properties</code> 与<code>application.yml</code> </p>
<p>spring boot项目中同时存在application.properties和application.yml文件时，两个文件都有效，但是application.properties的优先级会比application.yml高。<br>参考文档：<a href="https://www.hangge.com/blog/cache/detail_2459.html">https://www.hangge.com/blog/cache/detail_2459.html</a><br>在创建一个 SpringBoot 项目时，引入的 spring-boot-starter-web 依赖间接地引入了 snakeyaml 依赖， snakeyaml 会实现对 YAML 配置的解析。<br><code>application.yml</code> 的结构更加清晰，建议使用 <code>application.yml</code></p>
]]></content>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Swagger配置</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SpringBoot/Swagger%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Spring-boot整合Swagger2"><a href="#Spring-boot整合Swagger2" class="headerlink" title="Spring boot整合Swagger2"></a><strong>Spring boot整合Swagger2</strong></h2><p>Spring Boot整合Swagger2可以使用配置文件或者配置类来实现。下面分别介绍一下  </p>
<h2 id="一、使用配置文件来配置Swagger设置"><a href="#一、使用配置文件来配置Swagger设置" class="headerlink" title="一、使用配置文件来配置Swagger设置"></a>一、使用配置文件来配置Swagger设置</h2><h3 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1. 添加依赖"></a>1. 添加依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.spring4all&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;swagger-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.8.0.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-在配置文件application-yml添加配置"><a href="#2-在配置文件application-yml添加配置" class="headerlink" title="2. 在配置文件application.yml添加配置"></a>2. 在配置文件application.yml添加配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-在启动类添加注解-EnableSwagger2Doc"><a href="#3-在启动类添加注解-EnableSwagger2Doc" class="headerlink" title="3.在启动类添加注解@EnableSwagger2Doc"></a>3.在启动类添加注解@EnableSwagger2Doc</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication  </span><br><span class="line">@EnableSwagger2Doc  </span><br><span class="line">public class Artificial2BApplication &#123;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String\[\] args) &#123;  </span><br><span class="line">        SpringApplication.run(Artificial2BApplication.class, args);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、创建Java类来配置Swagger设置"><a href="#二、创建Java类来配置Swagger设置" class="headerlink" title="二、创建Java类来配置Swagger设置"></a>二、创建Java类来配置Swagger设置</h2><h3 id="1-在pom-xml添加依赖"><a href="#1-在pom-xml添加依赖" class="headerlink" title="1. 在pom.xml添加依赖"></a>1. 在pom.xml添加依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.9.2&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!--        导入swagger-ui依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.9.2&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-创建Swagger的Java配置类"><a href="#2-创建Swagger的Java配置类" class="headerlink" title="2. 创建Swagger的Java配置类"></a>2. 创建Swagger的Java配置类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SwaggerUtil &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Docket createRestApi()&#123;</span><br><span class="line">        return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .pathMapping(&quot;&#x2F;&quot;)</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(&quot;com.lzr.test.controller&quot;))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build()</span><br><span class="line">                .apiInfo(new ApiInfoBuilder()</span><br><span class="line">                .title(&quot;医疗系统&quot;)</span><br><span class="line">                        .description(&quot;用于管理患者信息的医疗系统平台&quot;)</span><br><span class="line">                        .version(&quot;1.0&quot;)</span><br><span class="line">                        .contact(new Contact(&quot;吕小白&quot;,&quot;https:www.baidu.com&quot;,&quot;****@qq.com&quot;)</span><br><span class="line">                        )</span><br><span class="line">                        .license(&quot;The Apache License&quot;)</span><br><span class="line">                        .licenseUrl(&quot;https:www.baidu.com&quot;)</span><br><span class="line">                        .build());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个配置文件随便放在哪个，路径下都可以，只要标有<code>@Configuration</code> 注解都会自动配置的，这就是Spring Boot的方便之处</p>
<h3 id="3-在启动类添加注解-EnableSwagger2"><a href="#3-在启动类添加注解-EnableSwagger2" class="headerlink" title="3. 在启动类添加注解@EnableSwagger2"></a>3. 在启动类添加注解@EnableSwagger2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@MapperScan(basePackages &#x3D; &quot;com.lzr.test.mapper&quot;)</span><br><span class="line">public class TestApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Object o&#x3D;new Object();</span><br><span class="line">        SpringApplication.run(TestApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动后访问效果：<br><img src="Swagger%E9%85%8D%E7%BD%AE/image_56.png"></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>常用注解</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SpringBoot/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>@ResponseBody 的作用其实是将 java 对象转为 json 格式的数据。</p>
<p>@responseBody 注解的作用是将 controller 的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到 response 对象的 body 区，通常用来返回 JSON 数据或者是XML数据。<br>注意：在使用此注解之后不会再走视图处理器，而是直接将数据写入到输入流中，他的效果等同于通过response 对象输出指定格式的数据。</p>
<p>@ResponseBody 是作用在方法上的， @ResponseBody 表示该方法的返回结果直接写入 HTTP response body 中，一般在异步获取数据时使用【也就是AJAX】。<br>注意：在使用 @RequestMapping后，返回值通常解析为跳转路径，但是加上 @ResponseBody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP response body 中。 比如异步获取 json 数据，加上 @ResponseBody 后，会直接返回 json 数据。@RequestBody 将 HTTP 请求正文插入方法中，使用适合的 HttpMessageConverter 将请求体写入某个对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">后台 Controller类中对应的方法：</span><br><span class="line">@RequestMapping(&quot;&#x2F;login.do&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public Object login(String name, String password, HttpSession session) &#123;</span><br><span class="line">	user &#x3D; userService.checkLogin(name, password);</span><br><span class="line">	session.setAttribute(&quot;user&quot;, user);</span><br><span class="line">	return new JsonResult(user);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@RequestBody是作用在形参列表上，用于将前台发送过来固定格式的数据【xml格式 或者 json等】封装为对应的 JavaBean 对象，</span><br><span class="line">封装时使用到的一个对象是系统默认配置的 HttpMessageConverter进行解析，然后封装到形参上。</span><br><span class="line">如上面的登录后台代码可以改为：</span><br><span class="line">@RequestMapping(&quot;&#x2F;login.do&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public Object login(@RequestBody User loginUuser, HttpSession session) &#123;</span><br><span class="line">	user &#x3D; userService.checkLogin(loginUser);</span><br><span class="line">	session.setAttribute(&quot;user&quot;, user);</span><br><span class="line">	return new JsonResult(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@RequestBody<br>@RequestBody 注解则是将 HTTP 请求正文插入方法中，使用适合的 HttpMessageConverter 将请求体写入某个对象。<br>作用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1) 该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定</span><br><span class="line">    到要返回的对象上； </span><br><span class="line">2) 再把HttpMessageConverter返回的对象数据绑定到 controller中方法的参数上。</span><br></pre></td></tr></table></figure>
<p>使用时机：</p>
<p>A) GET、POST方式提时， 根据request header Content-Type的值来判断:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    application&#x2F;x-www-form-urlencoded， 可选（即非必须，因为这种情况的数据@RequestParam, @ModelAttribute</span><br><span class="line">也可以处理，当然@RequestBody也能处理）； </span><br><span class="line">    multipart&#x2F;form-data, 不能处理（即使用@RequestBody不能处理这种格式的数据）； </span><br><span class="line">    其他格式， 必须（其他格式包括application&#x2F;json, application&#x2F;xml等。这些格式的数据，必须使用@RequestBody来处理）；</span><br></pre></td></tr></table></figure>
<p>B) PUT方式提交时， 根据request header Content-Type的值来判断:</p>
<p>application/x-www-form-urlencoded， 必须；multipart/form-data, 不能处理；其他格式， 必须；<br>说明：request的body部分的数据编码格式由header部分的Content-Type指定；</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(value &#x3D; &quot;user&#x2F;login&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">&#x2F;&#x2F; 将ajax（datas）发出的请求写入 User 对象中</span><br><span class="line">public User login(@RequestBody User user) &#123;   </span><br><span class="line">&#x2F;&#x2F; 这样就不会再被解析为跳转路径，而是直接将user对象写入 HTTP 响应正文中</span><br><span class="line">    return user;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>待办：  </p>
<ul>
<li> [ ] <code>@Resource</code> 与  <code>@Autowired</code> 的区别</li>
<li> [ ] <code>@MapperScan</code>  的用法</li>
<li></li>
</ul>
]]></content>
      <tags>
        <tag>spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>themeleaf 的常用标签</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SpringBoot/themeleaf%20%E7%9A%84%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>参考文档 <a href="https://www.yiibai.com/thymeleaf/standard-dialects.html">https://www.yiibai.com/thymeleaf/standard-dialects.html</a></p>
<h2 id="themeleaf-标准表达式"><a href="#themeleaf-标准表达式" class="headerlink" title="themeleaf 标准表达式"></a>themeleaf 标准表达式</h2><ul>
<li>  <code>$&#123;...&#125;</code> : <a href="#%E5%8F%98%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F">变量表达式</a>。</li>
<li>  <code>*&#123;...&#125;</code> : <a href="#%E9%80%89%E6%8B%A9%E8%A1%A8%E8%BE%BE%E5%BC%8F">选择表达式</a>。</li>
<li>  <code>#&#123;...&#125;</code> : <a href="#%E6%B6%88%E6%81%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F">消息表达式</a>。</li>
<li>  <code>@&#123;...&#125;</code> : <a href="#%E9%93%BE%E6%8E%A5%E8%A1%A8%E8%BE%BE%E5%BC%8F">链接表达式</a>。</li>
<li>  <code>~&#123;...&#125;</code> : <a href="#%E7%89%87%E6%AE%B5%E8%A1%A8%E8%BE%BE%E5%BC%8F">片段表达式</a>。</li>
</ul>
<h3 id="变量表达式"><a href="#变量表达式" class="headerlink" title="变量表达式"></a>变量表达式</h3><p>变量表达式是OGNL表达式 - 如果将_Thymeleaf_ 与_Spring_ - 集成在上下文变量上(也称为Spring术语中的模型属性)，则为_Spring EL_。 它们看起来像这样:</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">$&#123;session.user.name&#125;</span><br></pre></td></tr></table></figure>
<p>它们作为属性值或作为它们的一部分，取决于属性:</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;span th:text=<span class="string">&quot;$&#123;book.author.name&#125;&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>上面的表达式与下面是相同的(在OGNL和SpringEL中):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">((Book)context.getVariable(<span class="string">&quot;book&quot;</span>)).getAuthor().getName()</span><br></pre></td></tr></table></figure>
<p>但是不仅在涉及输出的场景中找到变量表达式，而且还可以使用更复杂的处理方式，如:条件，迭代…等等。</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;li th:each=<span class="string">&quot;book : $&#123;books&#125;&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>这里<code>$&#123;books&#125;</code>从上下文中选择名为<code>books</code>的变量，并在<code>th:each</code>中使用循环将其评估为迭代器。</p>
<h3 id="选择表达式"><a href="#选择表达式" class="headerlink" title="选择表达式"></a>选择表达式</h3><p>选择表达式就像变量表达式一样，它们不是整个上下文变量映射上执行，而是在先前选择的对象。 它们看起来像这样:</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">*&#123;customer.name&#125;</span><br></pre></td></tr></table></figure>
<p>它们所作用的对象由<code>th:object</code>属性指定:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;div th:object=<span class="string">&quot;$&#123;book&#125;&quot;</span>&gt;</span><br><span class="line">  ...</span><br><span class="line">  &lt;span th:text=&quot;*&#123;title&#125;&quot;&gt;...&lt;/span&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>所以这相当于:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// th:object=&quot;$&#123;book&#125;&quot;</span></span><br><span class="line">  <span class="keyword">final</span> Book selection = (Book) context.getVariable(<span class="string">&quot;book&quot;</span>);</span><br><span class="line">  <span class="comment">// th:text=&quot;*&#123;title&#125;&quot;</span></span><br><span class="line">  output(selection.getTitle());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消息表达式"><a href="#消息表达式" class="headerlink" title="消息表达式"></a>消息表达式</h3><p>消息表达式(通常称为文本外部化，国际化或i18n)允许从外部源(如:<code>.properties</code>)文件中检索特定于语言环境的消息，通过键来引用这引用消息。</p>
<p>在Spring应用程序中，它将自动与Spring的MessageSource机制集成。如下 -</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#&#123;main.title&#125;</span><br><span class="line">#&#123;message.entrycreated($&#123;entryId&#125;)&#125;</span><br></pre></td></tr></table></figure>
<p>以下是在模板中使用它们的方式:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">th</span> <span class="attr">th:text</span>=<span class="string">&quot;#&#123;header.address.city&#125;&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">th</span> <span class="attr">th:text</span>=<span class="string">&quot;#&#123;header.address.country&#125;&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>请注意，如果希望消息键由上下文变量的值确定，或者希望将变量指定为参数，则可以在消息表达式中使用变量表达式:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#&#123;$&#123;config.adminWelcomeKey&#125;($&#123;session.user.name&#125;)&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链接表达式"><a href="#链接表达式" class="headerlink" title="链接表达式"></a>链接表达式</h3><p>链接表达式在构建URL并向其添加有用的上下文和会话信息(通常称为URL重写的过程)。<br>因此，对于部署在Web服务器的<code>/myapp</code>上下文中的Web应用程序，可以使用以下表达式:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;a th:href=&quot;@&#123;/order/list&#125;&quot;&gt;...&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>可以转换成如下的东西:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;/myapp/order/list&quot;&gt;...&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>甚至，如果需要保持会话，并且cookie未启用(或者服务器还不知道)，那么生成的格式为:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/myapp/order/list;jsessionid=s2ds3fa31abd241e2a01932&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>网址也可以带参数，如下所示:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;a th:href=&quot;@&#123;/order/details(id=$&#123;orderId&#125;,type=$&#123;orderType&#125;)&#125;&quot;&gt;...&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>这将产生类似以下的结果 -</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注意＆符号会在标签属性中进行HTML转义... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/myapp/order/details?id=23&amp;type=online&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>链接表达式可以是相对的，在这种情况下，应用程序上下文将不会被加到URL的前面:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;a th:href=&quot;@&#123;../documents/report&#125;&quot;&gt;...&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>也是服务器相对的(同样，没有应用程序上下文的前缀):</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;~/contents/main&#125;&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>和协议相关(就像绝对URL一样，但浏览器将使用与正在显示的页面相同的HTTP或HTTPS协议):</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;//static.mycompany.com/res/initial&#125;&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当然，链接表达式也可以是绝对的:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;http://www.mycompany.com/main&#125;&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是绝对(或协议相对)URL ，在Thymeleaf链接表达式中应该添加什么值？ 很简单:由响应过滤器定义URL重写:在基于Servlet的Web应用程序中，对于每个输出的URL(上下文相对，相对，绝对…)，在显示URL之前，Thymeleaf总是调用<code>HttpServletResponse.encodeUrl(...)</code>机制。 这意味着一个过滤器可以通过包装HttpServletResponse对象来为应用程序执行自定义的URL重写。</p>
<h3 id="片段表达式"><a href="#片段表达式" class="headerlink" title="片段表达式"></a>片段表达式</h3><p>片段表达式是一种简单的方法用来表示标记的片段并将其移动到模板中。 由于这些表达式，片段可以被复制，传递给其他模板的参数等等。</p>
<p>最常见的是使用<code>th:insert</code>或<code>th:replace</code>来插入片段:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:insert</span>=<span class="string">&quot;~&#123;commons :: main&#125;&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是它们可以在任何地方使用，就像任何其他变量一样:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;div th:with=<span class="string">&quot;frag=~&#123;footer :: #main/text()&#125;&quot;</span>&gt;</span><br><span class="line">  &lt;p th:insert=<span class="string">&quot;$&#123;frag&#125;&quot;</span>&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>片段表达式可以有参数。</p>
]]></content>
      <tags>
        <tag>技术</tag>
        <tag>themeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title>maven的作用</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SpringBoot/1.%20Maven%E3%80%81Spring%20IO%E3%80%81SpringBoot%E7%AE%80%E4%BB%8B/Maven%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-Maven是干什么的"><a href="#1-Maven是干什么的" class="headerlink" title="1. Maven是干什么的"></a>1. Maven是干什么的</h2><p>Maven是依赖管理工具。</p>
<p>在Maven项目中有一个pom文件，文件中记录了项目运行所依赖的jar包。</p>
<p>pom文件中指定依赖包的名字、版本等信息，程序运行时自动从Mavne仓库中找对应版本的依赖包。</p>
<p>自动管理后就不用在项目的构建路径中添加相关依赖，使依赖管理更加方便快捷。</p>
]]></content>
  </entry>
  <entry>
    <title>Spring IO是什么</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SpringBoot/1.%20Maven%E3%80%81Spring%20IO%E3%80%81SpringBoot%E7%AE%80%E4%BB%8B/Spring%20IO%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Spring-IO"><a href="#Spring-IO" class="headerlink" title="Spring IO"></a>Spring IO</h2><p>Spring IO 项目用于帮助管理项目依赖的版本号,创建Maven项目后在官网找到将其拷贝放入pom中即可。</p>
<p>其中管理了大量依赖，各个依赖版本之间正确可用。</p>
<p>Spring IO 已经停止维护，鼓励使用Spring Boot。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">End of Life</span><br><span class="line">The Platform will reach the end of its supported life on 9 April 2019. Maintenence releases of both the Brussels and Cairo lines will continue to be published up until that time. Users of the Platform are encourage to start using Spring Boot’s dependency management directory, either by using spring-boot-starter-parent as their Maven project’s parent, or by importing the spring-boot-dependencies bom.</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>SpringBoot是什么</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SpringBoot/1.%20Maven%E3%80%81Spring%20IO%E3%80%81SpringBoot%E7%AE%80%E4%BB%8B/SpringBoot%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Spring-Boot是什么"><a href="#Spring-Boot是什么" class="headerlink" title="Spring Boot是什么"></a>Spring Boot是什么</h2><p>创建Spring Boot项目后，项目会自动添加spring-boot-starter-parent的父依赖项目，其就是Spring IO。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 https:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.8.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;&#x2F;parent&gt;</span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure>
<p>当前创建的项目需要使用的依赖只需要写名字就好，父项目自动使用合适的版本。</p>
<p>连接数据库要使用data-jpa，像下面这样写到dependencies中即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;        </span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
</search>
